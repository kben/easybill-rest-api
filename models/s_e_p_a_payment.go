// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SEPAPayment s e p a payment
//
// swagger:model SEPAPayment
type SEPAPayment struct {

	// Amount in cents (e.g. "150" = 1.50â‚¬)
	// Required: true
	Amount *int64 `json:"amount"`

	// created at
	// Read Only: true
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// If type is DEBIT, this field is overwritten with the selected bank account data on export.
	CreditorBic *string `json:"creditor_bic,omitempty"`

	// Mandatory if type is CREDIT. If type is DEBIT, this field is overwritten with the selected bank account data on export.
	CreditorIban *string `json:"creditor_iban,omitempty"`

	// Mandatory if type is CREDIT. If type is DEBIT, this field is overwritten with the selected bank account data on export.
	CreditorName *string `json:"creditor_name,omitempty"`

	// If type is CREDIT, this field is overwritten with the selected bank account data on export.
	DebitorBic *string `json:"debitor_bic,omitempty"`

	// Mandatory if type is DEBIT. If type is CREDIT, this field is overwritten with the selected bank account data on export.
	// Required: true
	DebitorIban *string `json:"debitor_iban"`

	// Mandatory if type is DEBIT. If type is CREDIT, this field is overwritten with the selected bank account data on export.
	// Required: true
	DebitorName *string `json:"debitor_name"`

	// document id
	// Required: true
	DocumentID *int64 `json:"document_id"`

	// If a date is set, this record is marked as exported
	// Format: date-time
	ExportAt *strfmt.DateTime `json:"export_at,omitempty"`

	// export error
	// Read Only: true
	ExportError string `json:"export_error,omitempty"`

	// id
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// CORE: SEPA Core Direct Debit<br/> COR1: SEPA-Basislastschrift COR1<br/> B2B: SEPA Business to Business Direct Debit
	// Required: true
	// Enum: [CORE COR1 B2B]
	LocalInstrument *string `json:"local_instrument"`

	// mandate date of signature
	// Required: true
	// Format: date
	MandateDateOfSignature *strfmt.Date `json:"mandate_date_of_signature"`

	// mandate id
	// Required: true
	// Max Length: 34
	MandateID *string `json:"mandate_id"`

	// reference
	// Required: true
	// Max Length: 35
	Reference *string `json:"reference"`

	// remittance information
	// Max Length: 140
	RemittanceInformation *string `json:"remittance_information,omitempty"`

	// Booking date
	// Format: date
	RequestedAt *strfmt.Date `json:"requested_at,omitempty"`

	// FRST: Erstlastschrift<br/> RCUR: Folgelastschrift<br/> OOFF: Einmallastschrift<br/> FNAL: Letztmalige Lastschrift
	// Required: true
	// Enum: [FRST OOFF FNAL RCUR]
	SequenceType *string `json:"sequence_type"`

	// type
	// Enum: [DEBIT CREDIT]
	Type *string `json:"type,omitempty"`

	// updated at
	// Read Only: true
	// Format: datetime
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`
}

// Validate validates this s e p a payment
func (m *SEPAPayment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebitorIban(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebitorName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExportAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMandateDateOfSignature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMandateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemittanceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSequenceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SEPAPayment) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateDebitorIban(formats strfmt.Registry) error {

	if err := validate.Required("debitor_iban", "body", m.DebitorIban); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateDebitorName(formats strfmt.Registry) error {

	if err := validate.Required("debitor_name", "body", m.DebitorName); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateDocumentID(formats strfmt.Registry) error {

	if err := validate.Required("document_id", "body", m.DocumentID); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateExportAt(formats strfmt.Registry) error {

	if swag.IsZero(m.ExportAt) { // not required
		return nil
	}

	if err := validate.FormatOf("export_at", "body", "date-time", m.ExportAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var sEPAPaymentTypeLocalInstrumentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CORE","COR1","B2B"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sEPAPaymentTypeLocalInstrumentPropEnum = append(sEPAPaymentTypeLocalInstrumentPropEnum, v)
	}
}

const (

	// SEPAPaymentLocalInstrumentCORE captures enum value "CORE"
	SEPAPaymentLocalInstrumentCORE string = "CORE"

	// SEPAPaymentLocalInstrumentCOR1 captures enum value "COR1"
	SEPAPaymentLocalInstrumentCOR1 string = "COR1"

	// SEPAPaymentLocalInstrumentB2B captures enum value "B2B"
	SEPAPaymentLocalInstrumentB2B string = "B2B"
)

// prop value enum
func (m *SEPAPayment) validateLocalInstrumentEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, sEPAPaymentTypeLocalInstrumentPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SEPAPayment) validateLocalInstrument(formats strfmt.Registry) error {

	if err := validate.Required("local_instrument", "body", m.LocalInstrument); err != nil {
		return err
	}

	// value enum
	if err := m.validateLocalInstrumentEnum("local_instrument", "body", *m.LocalInstrument); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateMandateDateOfSignature(formats strfmt.Registry) error {

	if err := validate.Required("mandate_date_of_signature", "body", m.MandateDateOfSignature); err != nil {
		return err
	}

	if err := validate.FormatOf("mandate_date_of_signature", "body", "date", m.MandateDateOfSignature.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateMandateID(formats strfmt.Registry) error {

	if err := validate.Required("mandate_id", "body", m.MandateID); err != nil {
		return err
	}

	if err := validate.MaxLength("mandate_id", "body", string(*m.MandateID), 34); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateReference(formats strfmt.Registry) error {

	if err := validate.Required("reference", "body", m.Reference); err != nil {
		return err
	}

	if err := validate.MaxLength("reference", "body", string(*m.Reference), 35); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateRemittanceInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.RemittanceInformation) { // not required
		return nil
	}

	if err := validate.MaxLength("remittance_information", "body", string(*m.RemittanceInformation), 140); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateRequestedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("requested_at", "body", "date", m.RequestedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var sEPAPaymentTypeSequenceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FRST","OOFF","FNAL","RCUR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sEPAPaymentTypeSequenceTypePropEnum = append(sEPAPaymentTypeSequenceTypePropEnum, v)
	}
}

const (

	// SEPAPaymentSequenceTypeFRST captures enum value "FRST"
	SEPAPaymentSequenceTypeFRST string = "FRST"

	// SEPAPaymentSequenceTypeOOFF captures enum value "OOFF"
	SEPAPaymentSequenceTypeOOFF string = "OOFF"

	// SEPAPaymentSequenceTypeFNAL captures enum value "FNAL"
	SEPAPaymentSequenceTypeFNAL string = "FNAL"

	// SEPAPaymentSequenceTypeRCUR captures enum value "RCUR"
	SEPAPaymentSequenceTypeRCUR string = "RCUR"
)

// prop value enum
func (m *SEPAPayment) validateSequenceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, sEPAPaymentTypeSequenceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SEPAPayment) validateSequenceType(formats strfmt.Registry) error {

	if err := validate.Required("sequence_type", "body", m.SequenceType); err != nil {
		return err
	}

	// value enum
	if err := m.validateSequenceTypeEnum("sequence_type", "body", *m.SequenceType); err != nil {
		return err
	}

	return nil
}

var sEPAPaymentTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEBIT","CREDIT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sEPAPaymentTypeTypePropEnum = append(sEPAPaymentTypeTypePropEnum, v)
	}
}

const (

	// SEPAPaymentTypeDEBIT captures enum value "DEBIT"
	SEPAPaymentTypeDEBIT string = "DEBIT"

	// SEPAPaymentTypeCREDIT captures enum value "CREDIT"
	SEPAPaymentTypeCREDIT string = "CREDIT"
)

// prop value enum
func (m *SEPAPayment) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, sEPAPaymentTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SEPAPayment) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *SEPAPayment) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "datetime", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SEPAPayment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SEPAPayment) UnmarshalBinary(b []byte) error {
	var res SEPAPayment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
