// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Project project
//
// swagger:model Project
type Project struct {

	// Project budget in cents (e.g. "150" = 1.50€)
	BudgetAmount int64 `json:"budget_amount,omitempty"`

	// Time budget in minutes (e.g. "90" = 1 hour and 30 minutes)
	BudgetTime int64 `json:"budget_time,omitempty"`

	// consumed amount
	// Read Only: true
	ConsumedAmount int64 `json:"consumed_amount,omitempty"`

	// consumed time
	// Read Only: true
	ConsumedTime int64 `json:"consumed_time,omitempty"`

	// customer id
	CustomerID *int64 `json:"customer_id,omitempty"`

	// due at
	// Format: date
	DueAt *strfmt.Date `json:"due_at,omitempty"`

	// Hourly rate in cents (e.g. "150" = 1.50€)
	HourlyRate float32 `json:"hourly_rate,omitempty"`

	// id
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// If omitted or null, the currently active login is used
	LoginID *int64 `json:"login_id,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// note
	Note *string `json:"note,omitempty"`

	// status
	// Enum: [OPEN DONE CANCEL]
	Status *string `json:"status,omitempty"`
}

// Validate validates this project
func (m *Project) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDueAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Project) validateDueAt(formats strfmt.Registry) error {

	if swag.IsZero(m.DueAt) { // not required
		return nil
	}

	if err := validate.FormatOf("due_at", "body", "date", m.DueAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var projectTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OPEN","DONE","CANCEL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectTypeStatusPropEnum = append(projectTypeStatusPropEnum, v)
	}
}

const (

	// ProjectStatusOPEN captures enum value "OPEN"
	ProjectStatusOPEN string = "OPEN"

	// ProjectStatusDONE captures enum value "DONE"
	ProjectStatusDONE string = "DONE"

	// ProjectStatusCANCEL captures enum value "CANCEL"
	ProjectStatusCANCEL string = "CANCEL"
)

// prop value enum
func (m *Project) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, projectTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Project) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Project) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Project) UnmarshalBinary(b []byte) error {
	var res Project
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
