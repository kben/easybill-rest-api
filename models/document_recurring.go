// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DocumentRecurring document recurring
//
// swagger:model DocumentRecurring
type DocumentRecurring struct {

	// as draft
	AsDraft *bool `json:"as_draft,omitempty"`

	// Date of last exectution day or number of times to exectute
	EndDateOrCount *string `json:"end_date_or_count,omitempty"`

	// frequency
	// Enum: [DAILY WEEKLY MONTHLY YEARLY]
	Frequency *string `json:"frequency,omitempty"`

	// frequency special
	// Enum: [LASTDAYOFMONTH]
	FrequencySpecial *string `json:"frequency_special,omitempty"`

	// interval
	Interval *int64 `json:"interval,omitempty"`

	// is notify
	IsNotify *bool `json:"is_notify,omitempty"`

	// is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// is sepa
	IsSepa *bool `json:"is_sepa,omitempty"`

	// is sign
	IsSign *bool `json:"is_sign,omitempty"`

	// Must be in the future
	// Required: true
	// Format: date
	NextDate *strfmt.Date `json:"next_date"`

	// Option is used to determine what date is used for the payment if is_paid is true. "next_valid_date" selects the next workday in regards to the created date of the document if the date falls on a saturday or sunday.
	// Enum: [created_date due_date next_valid_date]
	PaidDateOption *string `json:"paid_date_option,omitempty"`

	// send as
	// Enum: [EMAIL FAX POST]
	SendAs *string `json:"send_as,omitempty"`

	// sepa local instrument
	// Enum: [CORE COR1 B2B]
	SepaLocalInstrument *string `json:"sepa_local_instrument,omitempty"`

	// sepa reference
	SepaReference *string `json:"sepa_reference,omitempty"`

	// sepa remittance information
	SepaRemittanceInformation *string `json:"sepa_remittance_information,omitempty"`

	// sepa sequence type
	// Enum: [FRST OOFF FNAL RCUR]
	SepaSequenceType *string `json:"sepa_sequence_type,omitempty"`

	// status
	// Enum: [RUNNING PAUSE STOP WAITING]
	Status *string `json:"status,omitempty"`
}

// Validate validates this document recurring
func (m *DocumentRecurring) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequencySpecial(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNextDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaidDateOption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSendAs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSepaLocalInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSepaSequenceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var documentRecurringTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAILY","WEEKLY","MONTHLY","YEARLY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeFrequencyPropEnum = append(documentRecurringTypeFrequencyPropEnum, v)
	}
}

const (

	// DocumentRecurringFrequencyDAILY captures enum value "DAILY"
	DocumentRecurringFrequencyDAILY string = "DAILY"

	// DocumentRecurringFrequencyWEEKLY captures enum value "WEEKLY"
	DocumentRecurringFrequencyWEEKLY string = "WEEKLY"

	// DocumentRecurringFrequencyMONTHLY captures enum value "MONTHLY"
	DocumentRecurringFrequencyMONTHLY string = "MONTHLY"

	// DocumentRecurringFrequencyYEARLY captures enum value "YEARLY"
	DocumentRecurringFrequencyYEARLY string = "YEARLY"
)

// prop value enum
func (m *DocumentRecurring) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeFrequencyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencyEnum("frequency", "body", *m.Frequency); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypeFrequencySpecialPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LASTDAYOFMONTH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeFrequencySpecialPropEnum = append(documentRecurringTypeFrequencySpecialPropEnum, v)
	}
}

const (

	// DocumentRecurringFrequencySpecialLASTDAYOFMONTH captures enum value "LASTDAYOFMONTH"
	DocumentRecurringFrequencySpecialLASTDAYOFMONTH string = "LASTDAYOFMONTH"
)

// prop value enum
func (m *DocumentRecurring) validateFrequencySpecialEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeFrequencySpecialPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateFrequencySpecial(formats strfmt.Registry) error {

	if swag.IsZero(m.FrequencySpecial) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencySpecialEnum("frequency_special", "body", *m.FrequencySpecial); err != nil {
		return err
	}

	return nil
}

func (m *DocumentRecurring) validateNextDate(formats strfmt.Registry) error {

	if err := validate.Required("next_date", "body", m.NextDate); err != nil {
		return err
	}

	if err := validate.FormatOf("next_date", "body", "date", m.NextDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypePaidDateOptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["created_date","due_date","next_valid_date"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypePaidDateOptionPropEnum = append(documentRecurringTypePaidDateOptionPropEnum, v)
	}
}

const (

	// DocumentRecurringPaidDateOptionCreatedDate captures enum value "created_date"
	DocumentRecurringPaidDateOptionCreatedDate string = "created_date"

	// DocumentRecurringPaidDateOptionDueDate captures enum value "due_date"
	DocumentRecurringPaidDateOptionDueDate string = "due_date"

	// DocumentRecurringPaidDateOptionNextValidDate captures enum value "next_valid_date"
	DocumentRecurringPaidDateOptionNextValidDate string = "next_valid_date"
)

// prop value enum
func (m *DocumentRecurring) validatePaidDateOptionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypePaidDateOptionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validatePaidDateOption(formats strfmt.Registry) error {

	if swag.IsZero(m.PaidDateOption) { // not required
		return nil
	}

	// value enum
	if err := m.validatePaidDateOptionEnum("paid_date_option", "body", *m.PaidDateOption); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypeSendAsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EMAIL","FAX","POST"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeSendAsPropEnum = append(documentRecurringTypeSendAsPropEnum, v)
	}
}

const (

	// DocumentRecurringSendAsEMAIL captures enum value "EMAIL"
	DocumentRecurringSendAsEMAIL string = "EMAIL"

	// DocumentRecurringSendAsFAX captures enum value "FAX"
	DocumentRecurringSendAsFAX string = "FAX"

	// DocumentRecurringSendAsPOST captures enum value "POST"
	DocumentRecurringSendAsPOST string = "POST"
)

// prop value enum
func (m *DocumentRecurring) validateSendAsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeSendAsPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateSendAs(formats strfmt.Registry) error {

	if swag.IsZero(m.SendAs) { // not required
		return nil
	}

	// value enum
	if err := m.validateSendAsEnum("send_as", "body", *m.SendAs); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypeSepaLocalInstrumentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CORE","COR1","B2B"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeSepaLocalInstrumentPropEnum = append(documentRecurringTypeSepaLocalInstrumentPropEnum, v)
	}
}

const (

	// DocumentRecurringSepaLocalInstrumentCORE captures enum value "CORE"
	DocumentRecurringSepaLocalInstrumentCORE string = "CORE"

	// DocumentRecurringSepaLocalInstrumentCOR1 captures enum value "COR1"
	DocumentRecurringSepaLocalInstrumentCOR1 string = "COR1"

	// DocumentRecurringSepaLocalInstrumentB2B captures enum value "B2B"
	DocumentRecurringSepaLocalInstrumentB2B string = "B2B"
)

// prop value enum
func (m *DocumentRecurring) validateSepaLocalInstrumentEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeSepaLocalInstrumentPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateSepaLocalInstrument(formats strfmt.Registry) error {

	if swag.IsZero(m.SepaLocalInstrument) { // not required
		return nil
	}

	// value enum
	if err := m.validateSepaLocalInstrumentEnum("sepa_local_instrument", "body", *m.SepaLocalInstrument); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypeSepaSequenceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FRST","OOFF","FNAL","RCUR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeSepaSequenceTypePropEnum = append(documentRecurringTypeSepaSequenceTypePropEnum, v)
	}
}

const (

	// DocumentRecurringSepaSequenceTypeFRST captures enum value "FRST"
	DocumentRecurringSepaSequenceTypeFRST string = "FRST"

	// DocumentRecurringSepaSequenceTypeOOFF captures enum value "OOFF"
	DocumentRecurringSepaSequenceTypeOOFF string = "OOFF"

	// DocumentRecurringSepaSequenceTypeFNAL captures enum value "FNAL"
	DocumentRecurringSepaSequenceTypeFNAL string = "FNAL"

	// DocumentRecurringSepaSequenceTypeRCUR captures enum value "RCUR"
	DocumentRecurringSepaSequenceTypeRCUR string = "RCUR"
)

// prop value enum
func (m *DocumentRecurring) validateSepaSequenceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeSepaSequenceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateSepaSequenceType(formats strfmt.Registry) error {

	if swag.IsZero(m.SepaSequenceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSepaSequenceTypeEnum("sepa_sequence_type", "body", *m.SepaSequenceType); err != nil {
		return err
	}

	return nil
}

var documentRecurringTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RUNNING","PAUSE","STOP","WAITING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		documentRecurringTypeStatusPropEnum = append(documentRecurringTypeStatusPropEnum, v)
	}
}

const (

	// DocumentRecurringStatusRUNNING captures enum value "RUNNING"
	DocumentRecurringStatusRUNNING string = "RUNNING"

	// DocumentRecurringStatusPAUSE captures enum value "PAUSE"
	DocumentRecurringStatusPAUSE string = "PAUSE"

	// DocumentRecurringStatusSTOP captures enum value "STOP"
	DocumentRecurringStatusSTOP string = "STOP"

	// DocumentRecurringStatusWAITING captures enum value "WAITING"
	DocumentRecurringStatusWAITING string = "WAITING"
)

// prop value enum
func (m *DocumentRecurring) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, documentRecurringTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DocumentRecurring) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DocumentRecurring) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DocumentRecurring) UnmarshalBinary(b []byte) error {
	var res DocumentRecurring
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
